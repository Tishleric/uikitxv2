---
description: 
globs: 
alwaysApply: true
---
# Large-Scale Design Principles

## High-Impact Principles

- **Layered, hierarchical design:** Organize code into *layers* (levels) where each module or package at level N depends only on those at lower levels (N-1, N-2, etc.). This produces a directed acyclic dependency graph and clear separation of concerns. Higher-level policies and business logic reside at the top, while low-level utilities and foundations are at the bottom.  
- **Acyclic dependencies (no cycles):** Ensure the dependency graph of components has no circular dependencies. Cycles make reasoning, testing, and building the system much harder (you can't compile or understand one component in isolation). If you detect a cycle, refactor by introducing an interface or an intermediate module to break the loop.  
- **Small, cohesive components (physical units):** Use *components* as the atomic unit of code release and reuse. In C++ terms, John Lakos suggests one class or cohesive cluster of functionality per component (often one .h/.cpp pair). In any language, think of components as modules/packages that encapsulate a single concept. This granularity allows independent development and testing of each piece.  
- **Explicit packaging and levels:** Group related components into packages (or libraries), and assign a level number to each package to indicate its position in the dependency hierarchy. E.g., Level 0 might be low-level utilities, higher levels build on those. A package should only depend on packages of lower (more fundamental) level. This disciplined approach prevents "spaghetti" linkage between parts of the system.  
- **Stable interfaces, evolve internals:** Treat published interfaces of components as contracts that remain stable for clients. Internally, you can iterate and improve, but keep the external behavior/backward compatibility as much as possible. This allows other teams to use your component without fear of it breaking frequently. When changes to interface are needed, batch them or provide migration paths.  
- **Reuse before buy/build:** Reuse isn't just a buzzword – it's an economic necessity in large systems. *"Every attempt must be made to use existing libraries."* Before writing new code, look into your organization's library of components or well-regarded external libraries. It's often faster and safer to integrate a tested component than to create and debug a new one from scratch.  
- **Code as an asset (Software capital):** Treat your codebase as a long-term asset rather than disposable. Good design and modularity are investments that pay off as the codebase grows. *"Software should be treated as an asset… rather than an expense…"* – meaning time spent structuring code well yields returns in easier maintenance and extension. Encourage a culture of building components that can be leveraged across projects (not quick hacks that solve only the immediate problem).  
- **Balance reusable vs. collaborative code:** Not every piece of code needs to be a generic library. It's fine to have modules that are *collaborative* (specific to one application but broken into components for that app's sanity) rather than fully reusable elsewhere. Identify core functionalities that are common and factor those into reusable components, but keep application-specific logic separate. This avoids over-engineering everything for reuse when only some parts benefit from it.  
- **Physical design matters:** The arrangement of source files, libraries, and build dependencies is crucial. Slow build times or complicated link dependencies can sap productivity. Strive for *fast, independent compilation units* – if a change in one component triggers recompilation of a huge portion of the codebase, re-examine dependencies. Use forward declarations, minimal includes, and dependency inversion to cut build coupling.  
- **Independent development and testing:** Each component (or small package of components) should be testable on its own, ideally with a dedicated test driver or unit tests. This encourages parallel development (teams can work on different components with well-defined interfaces) and easier debugging (you can localize faults to a specific component).  
- **Facades and dependency control:** Use facade patterns or API gateways between subsystems. For example, if a high-level module needs data from a lower subsystem, instead of depending on many modules of that subsystem, depend on a single Facade class or interface. This limits the points of contact and makes it easier to swap out implementations or make large changes in one part without breaking others.  
- **Levelization and incremental growth:** When adding new features, integrate them at the appropriate level. If a new feature cuts across layers, consider factoring some logic into a lower layer so higher-level parts remain unaffected. Over time, continuously *levelize* – push generic utilities downwards into common libraries, and keep domain-specific logic upward. This process gradually yields a robust layered architecture.  
- **Visibility control:** In large codebases, controlling what is exposed is important. Use language features (like `internal` or non-exported symbols, or Python's `_` convention) to limit the visibility of internal module details. This prevents unwarranted coupling because other modules can't depend on things they're not supposed to see.  
- **Naming and organization:** Establish clear naming conventions for packages, modules, and components that reflect the layering. For instance, you might prefix low-level utility components with `base_` or put them in a `base` package. This provides a quick visual cue of a component's level and intended use.  
- **Continuous architecture governance:** As the system evolves, periodically review the dependency structure. Tools can analyze include/import graphs to identify cycles or growth in undesirable directions. Make architecture a part of the definition-of-done: code that would introduce a cycle or inappropriate dependency should be refactored before merge. This vigilance keeps the design from degrading under schedule pressure.

## Antipatterns to Avoid

- **Cyclic dependencies:** Any form of cyclic dependency between modules or packages is a big no-no. It indicates poor partitioning. Avoid mutual inclusion or import loops. If two components absolutely need each other's functionality, consider merging them into one, or better, introduce an interface to break the cycle (have one component depend on an abstract interface that the other implements, rather than directly on the implementation).  
- **"Big ball of mud":** A system where everything depends on everything (no clear structure) is an architecture antipattern. If adding a tiny feature requires touching code in many places all over the system, that's symptomatic of this. Avoid it by adhering to layering and proper separation. Anytime you sense the architecture dissolving into entanglement, step back and refactor.  
- **Monolithic mega-modules:** Don't create modules that lump too many responsibilities (e.g., a single `Utils` module that has 500 unrelated functions). Such modules become dumping grounds and create excessive rebuild dependencies. Break them into coherent submodules. Similarly, overly large libraries (~thousands of classes) that everyone must link against can slow builds and cause unwanted coupling – consider splitting along functional lines.  
- **Copy-pasted code across codebase:** In a large system, it's easy for duplicate code to sprout (two teams solving the same problem in different areas). This leads to inconsistent behavior and maintenance overhead. Avoid this by actively encouraging reuse and communication – have a searchable repository of components, and promote a culture of "if it exists, use it; if not, create it for all." If you find copy-paste, consolidate it.  
- **Upward dependencies:** Lower-level utilities should not depend on higher-level modules. For example, a math library should not import from a GUI module. Such inverted dependencies create cycles and weird coupling. Use dependency inversion (where a high-level module defines an interface and the low-level module implements it) if a lower layer needs to callback or communicate upward. This keeps compile-time dependencies one-way.  
- **Poor physical separation:** If your source code organization doesn't reflect logical structure (e.g., all files dumped in one directory, or naming not indicating layering), it's an antipattern. It makes it hard for new developers to find things and understand boundaries. Each top-level component or layer should correspond to a directory or identifiable prefix.  
- **Lack of internal boundaries ("mini-architectures"):** In large applications, each subsystem might need its own internal structure. An antipattern is treating a huge subsystem as a monolith internally. Instead, apply the same principles of layering and modularity *within* subsystems. If not, those subsystems become unmanageable and can't be worked on by multiple teams effectively.  
- **Reinventing instead of refactoring:** When faced with a system that's hard to change, a common antipattern is to *rewrite or add parallel implementations* rather than refactor the existing design (because it seems too hard). This leads to duplicate systems (say, two JSON parsers in the codebase) and confusion. It's better to invest in improving the existing component (or replacing it wholesale but one component at a time) than piling on redundant functionality.  
- **Neglecting build system impact:** In C++ large scale, including one header too many can blow up compile times. In any language, having enormous modules can slow incremental builds or deployments. Don't ignore the signals: if build or start-up times grow, address architecture (split modules, use lazy-loading, etc.). It's an antipattern to say "we'll just throw hardware at it" once build times or binary sizes become a problem; instead, fix the root cause in design.  
- **No clear ownership:** In large projects, if no one knows which team or person owns a component, that component can become a bottleneck or fall into disrepair. Ensure that each module or subsystem has a clear owner or owning team. Lack of ownership is an organizational antipattern that affects technical quality. Without an owner, code might be modified inconsistently or not at all when needed.  
- **Permissive dependency policies:** If developers can depend on any module arbitrarily with no review, the architecture can degrade. Avoid the antipattern of having no rules or checks on dependencies. Instead, enforce guidelines (e.g., via code reviews or even automated dependency checks) so that you don't suddenly find a high-level UI module depending on a low-level utility in a backward way, or two features mutually depending on each other's internals.

## Heuristics & Checklists

- **Draw the dependency graph:** Periodically, visualize the module dependency graph (there are tools to generate this). Verify it's acyclic and roughly layered. If you see a cycle or a surprising dependency edge (module A depending on something far out of its expected layer), flag it for refactoring.  
- **Review changes for layering:** In code reviews, include an "architecture check". If a change introduces a new dependency (import/include) on a module that seems out of layer or context, question it. It's easier to correct a bad dependency when it's introduced than to unravel it later.  
- **One class per component guideline:** In C++ Lakos suggests one class per .h/.cpp. As a checklist item, if a component file grows to contain many classes or responsibilities, consider splitting it. In higher-level languages, if a single module (file) has many unrelated functions or classes, break it into multiple modules. Keep physical components manageable and focused.  
- **Component test:** Does each component have a test driver or suite? If not, it might be too entangled to test on its own, which indicates high coupling. Aim to write a small test (or even a `main` function or REPL script) that instantiates and uses the component in isolation to verify it works. This is both a design and quality check.  
- **Include what you use (and no more):** For C/C++: each file should include only the headers it directly needs, not relying on indirect includes via other headers. This reduces build times and coupling. In other languages, similarly ensure you only import what you actually use. This discipline prevents unintended tight coupling.  
- **Search for duplicates:** Use tools or scripts to scan for similar code or functions with similar names. If two implementations look similar, unify them. A large codebase can accidentally accumulate redundant code – proactively seek and destroy duplication.  
- **Monitor build metrics:** Keep an eye on build times, binary sizes, cycle times. When a metric spikes, treat it like a code smell. For instance, if a minor code change triggers a rebuild of 1000 files, investigate why – maybe a frequently included header includes too much, or a popular module has grown too entangled.  
- **Encourage modular thinking:** In planning meetings or design discussions, frame work in terms of modules: "What new components do we need?", "Can we extend component X to do this?", "Which layer should this functionality live in?" This mindset helps developers naturally gravitate to solutions that fit the architecture, rather than piling on hacks.  
- **Refactoring budget:** Allocate time in each release or sprint for architectural maintenance. For example, resolving a cycle, splitting a large module, or simplifying dependencies. If you treat architecture fixes as part of regular work (instead of only doing features), you prevent big issues later.  
- **Document the architecture:** Maintain a high-level system diagram and a brief text describing the roles of major subsystems and their layering. Keep it updated (maybe in a README or wiki). This helps onboarding new developers and also serves as a guide for keeping the architecture coherent. If the code and the documentation start diverging, it's a sign architecture erosion might be happening.  
- **Cross-team API reviews:** If one team provides a library or service for others, have a design review of that API involving consumers. This ensures the component boundaries are sound and the dependency will be easy to use and stable. It's cheaper to adjust an interface before multiple components depend on it.  
- **Graceful deprecation plan:** In large systems, you'll replace or upgrade components over time. Have a strategy for deprecating old components (mark them, provide alternatives, eventually remove). Avoid the antipattern of keeping dead code or parallel systems forever. A clean retirement of modules keeps the system lean.

## Key Quotes / Mnemonics

- "Dependencies among packages should form a partial order (no cycles)."  
- "A package at Level N should depend only on packages at Level N-1."  
- "Software modules must have an acyclic dependency graph."  
- "Every attempt must be made to use existing libraries."  
- "Software should be treated as an asset, not an expense."

## "When in doubt" Defaults

- **When in doubt, enforce boundaries:** Default to disallowing a questionable dependency or coupling. It's better to require an extra step (like creating an interface or moving some code) than to allow a shortcut that breaks architecture. Say "no" first to shortcuts that violate layering; find a more architecture-compliant solution.  
- **When in doubt, make a new module:** If a piece of code doesn't clearly belong in an existing component, create a new one for it rather than squeezing it in improperly. New components are cheap; architectural messes are expensive.  
- **When in doubt, reuse rather than reimplement:** If you suspect functionality exists elsewhere in the system or in a library, take the time to search for it. It's often faster to adapt an existing solution than to write, debug, and integrate a new one.  
- **When in doubt, keep it independent:** Write code as if it might be moved out into a library later. That means minimize external dependencies, keep functions pure where possible, and isolate hacks. This way, your code is more modular by default.  
- **When in doubt, maintain stability:** Avoid drastic changes to widely-used interfaces without a very good reason. If you're uncertain, preserve backward compatibility. It's usually better to add new functions or flags (to extend) than to change existing behavior in-place. Stability builds trust in the structure of a large codebase.

## Modern Context Applications

- **Microservices Architecture:** These principles apply at the service level – services should have clear dependencies, no cycles, stable APIs.
- **Monorepo Management:** In monorepos, these principles become even more critical. Use tools like Bazel or Nx that enforce dependency rules.
- **Cloud-Native Design:** Components become containers/functions, packages become services, but the layering and dependency principles remain.

