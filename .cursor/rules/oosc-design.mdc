---
description: 
globs: 
alwaysApply: true
---
# Object-Oriented Software Construction (OOSC) Design Principles

## High-Impact Principles

- **Design by Contract (DbC):** Define precise **contracts** for software elements – each module or method should have clear preconditions (what it expects), postconditions (what it ensures), and invariants (what always holds true). By making these explicit, you catch errors early and build more reliable software. The code should actively check critical assumptions (using assertions) during development to prevent bugs from going silent.  
- **Open-Closed Principle:** Software entities (classes, modules, functions) should be **open for extension** but **closed for modification**. In practice, this means design your system so you can add new functionality by adding new code (e.g., subclasses, new functions) rather than changing existing code. This leads to more stable and maintainable code, because existing, tested code isn't being constantly tweaked when requirements change.  
- **Command–Query Separation (CQS):** *"Asking a question should not change the answer."* Every method should be either a **command** (performs an action with side effects) or a **query** (returns data, without side effects), but not both. This separation makes code easier to reason about – you can call queries freely without worrying they will modify state, and commands clearly stand out as operations that change state.  
- **High cohesion, low coupling:** Aim for *high cohesion* (each module/class has one well-defined purpose and its elements are strongly related) and *low coupling* (minimal dependencies between modules). A design with high cohesion is easier to understand and reuse, and low coupling means changes in one place have little impact elsewhere. These principles underlie many of Meyer's recommendations (e.g., modularity, single responsibility, etc.).  
- **Single Choice Principle:** Avoid duplicating the knowledge of alternatives across the system. *"Whenever a system must support a set of alternatives, one and only one module should know their exhaustive list."* In other words, if you have a set of variants (say, handling multiple file formats or transaction types), centralize the decision of which variant to use in one place (like a factory or strategy) rather than scattering conditionals throughout the code. This prevents inconsistency and makes extending alternatives easier (you update one module).  
- **Uniform Access Principle:** Whether a client is obtaining data from memory or computing it on the fly should not affect how it's accessed. In OOSC terms, accessing an attribute or invoking a parameterless method should look the same. This principle encourages encapsulation: you can change a field to a computed property without impacting callers. (In Python, properties and in C++/Java, use of getters hide implementation; in Eiffel, attribute access and function call use identical syntax.)  
- **Defensive Design vs. Contractual Design:** Meyer advocates a contractual approach – a routine is responsible for its postcondition if callers meet the precondition. This means don't overly defensive-check things that the contract says should be true (it can hide bugs). Rely on contracts: the caller ensures preconditions, the routine guarantees postconditions. Use assertions to make sure contracts are not violated during development.  
- **Robustness through controlled exceptions:** When contracts are broken (an unexpected situation), handle it in a defined way. For example, if a routine cannot fulfill its contract, it should signal an exception. OOSC suggests exceptions be used for contract violations and truly abnormal cases, not for normal flow. Also, a module catching an exception should know how to recover or else propagate it – don't catch and ignore.  
- **Extendibility and reusability:** Design classes and modules that can be extended or reused in new contexts. This often means abstracting the general concept from the specific. For instance, if you find two similar classes, consider extracting a common base class or utility functions. However, ensure the abstraction is valid; don't force reuse via inheritance where composition or simple functions might be clearer.  
- **Methodological consistency:** Follow a consistent methodology for analysis and design. In OOSC, Meyer lays out steps from analysis to design to implementation. Sticking to a method (like carefully identifying classes and their contracts before coding) leads to more thought-out designs. Ad-hoc design can work for small scripts but not large systems.  
- **Quality focus:** Always consider software quality factors – **correctness, robustness, extendibility, reusability** – during design. For example, ask yourself: Is this design easy to extend for future requirements (open-closed)? Will it be reusable in other projects or contexts? How will it behave if given bad inputs (robustness)? And, foremost, does it fulfill the specifications exactly (correctness)? Balancing these concerns yields well-engineered software.  
- **Avoiding redundancy:** Don't allow the same knowledge to exist in multiple places (a nod to DRY, which aligns with Meyer's Single Choice principle). This applies to code, but also to things like documentation vs. code – generate documentation from code or vice versa to ensure there's a single source of truth.  
- **Clear abstraction layers:** Structure your system in layers (or tiers) where each layer has a well-defined responsibility. Upper layers use services of lower layers but not vice versa. For example, a GUI layer might use a domain logic layer, which in turn uses a data access layer. This layering (similar to the idea of *"onion architecture"* or *"rings"* mentioned in OOSC) ensures changes in one layer (like swapping a database) have limited impact.  
- **Polymorphism over conditionals:** Use polymorphism (inheritance or interface implementations) to handle variations in behavior rather than big if/else or switch statements scattered in code. For instance, instead of an if chain checking types, have each type implement a method in a class hierarchy. This ties in with open-closed: adding a new type then just means adding a new class, not modifying a bunch of conditional logic.  
- **Document and justify decisions:** OOSC encourages not just doing things right, but also recording why a certain design decision was made (especially if it's complex). Key design decisions, assumptions, and contract rationales should be documented. This helps future maintainers (and yourself) understand the constraints of the design.

## Antipatterns to Avoid

- **Mixing commands and queries:** Do not write methods that both modify state and return a useful result. This ambiguity can lead to unexpected side effects and confusion (violation of CQS). For example, a method `balance.withdraw(amount)` that returns the new balance *and* changes it is worse than separate `withdraw` (command) and `get_balance` (query).  
- **Violating Liskov Substitution (LSP):** LSP (related to OCP) means subclasses should be usable anywhere the base is expected. Antipatterns include overriding a method and *narrowing* the specification (e.g., stronger precondition or weaker postcondition), which breaks substitutability. Don't surprise clients: if class B inherits A, any behavior guaranteed by A must hold in B too.  
- **Overly defensive coding against the contract:** For instance, checking for null or validating parameters inside a method when your design's contract says the caller shouldn't pass null. This clutters code and can mask contract violations. Instead, use assertions to document the precondition but not code to silently correct it – a failure should be detected during testing.  
- **Exception misuse:** Using exceptions for flow control (e.g., using try/except to break out of loops instead of proper loop constructs) or swallowing exceptions completely (`try: ... except: pass`) are bad practices. This goes against the idea that exceptions signal something exceptional. Catch exceptions at a level that can do something about them, or let them propagate.  
- **God classes / too many responsibilities:** Avoid classes that know too much or do too much (often called "God classes" or high coupling hubs). In OOP, this violates cohesion and modularity. For example, a class that manages UI, database, and business logic all together is an antipattern – such a class is hard to reuse or maintain.  
- **Parallel class hierarchies:** A sign of poor design is needing to update multiple class hierarchies for one concept change (e.g., you have `CarUI`, `CarLogic`, `CarDB` classes in separate hierarchies that all must be modified to add one feature for "Car"). Instead, co-locate related functionality or use composition to avoid this duplication of structure.  
- **Multiple inheritance misuse:** While multiple inheritance can be powerful (as in Eiffel, which Meyer designed), it can also create complexity (the diamond problem). Avoid multiple inheritance unless you truly need to model something that inherently has two types of "is-a" relationships and your language handles it safely. Prefer interfaces or mixins (which contain no state) or composition to simulate multiple facets if possible.  
- **Fat interfaces / classes:** An interface (or class) that has too many methods is hard to implement and mock, and indicates it might be doing too much. Don't require users to implement methods they may not need. Breaking interfaces into smaller ones (interface segregation principle) or classes into smaller collaborators can improve this.  
- **Undocumented assumptions:** If your module assumes something (e.g., a function must be called after another, or a global setting must be in place), it's an antipattern to not make that explicit. Unstated assumptions lead to bugs when someone else (or you later) use the code incorrectly. Document or enforce assumptions via contracts or code.  
- **Global mutable state:** OOSC Chapter 18 discusses global objects and constants. Mutable globals (like a global list that various parts of the program modify) are dangerous – they introduce non-local effects and ordering issues. Avoid them; if you need a global, make it constant or restrict access tightly (perhaps via accessor functions that enforce invariants).  
- **Duplicated code paths:** If two different modules implement nearly the same logic in slightly different ways, that's an antipattern. It often happens when there is no Single Choice principle – e.g., multiple modules know about all file format types and each has a switch over them. Consolidate such logic to one place to avoid divergence and bugs.  
- **Ignoring quality factors:** Don't design only for happy-path functionality while ignoring correctness, robustness, etc. For example, not handling erroneous input at all, or not considering how the design will scale with more features, will haunt you. Avoid a design that only works in ideal conditions but is brittle in real-world use.

## Heuristics & Checklists

- **Contract completeness check:** For each class or major function, explicitly list its preconditions, postconditions, and invariants (even informally, in comments or a notebook). Have you covered normal cases and edge cases? If something isn't clear in the contract, refine it. During code reviews, discuss contracts – does the implementation fulfill its promises and assume its prerequisites?  
- **OCP question:** When implementing a change request or new feature, ask "Could I implement this by adding new code rather than changing existing code?" If yes, try to do so (e.g., add a new subclass or new method). If you find you must modify a lot of existing code for a minor extension, it's a sign the design might need refactoring towards Open-Closed (maybe introduce an abstraction).  
- **CQS audit:** Look through your class APIs – are any getters doing hidden modifications? Are any commands returning something that suggests they should be split? Adjust methods to be one or the other. For example, if `update_and_get_status()` both changes state and returns info, consider splitting that into `update()` and `get_status()`.  
- **Single Responsibility check (cohesion):** Can you describe what each module is responsible for in one sentence without using "and"? If you catch yourself saying "Module X does A and B," consider if A and B are separate enough to be in different modules. High cohesion means each piece does one thing well.  
- **Coupling check:** Examine inter-module dependencies. Draw a quick diagram. If everything depends on everything, that's a red flag. Try to introduce intermediate abstractions or decouple via interfaces. If module A and B call each other (cycle), break that by introducing an interface or moving functionality so the dependency goes one way only.  
- **Exception policy:** Decide how your system handles errors: which layer catches which exceptions? Ensure that lower-level exceptions are either translated to higher-level ones or allowed to bubble up. Document this. A good heuristic: only catch an exception if you can either *fix* the problem or *translate* it to something the caller of your component would understand. Otherwise, let it propagate.  
- **Testing and DbC:** Write unit tests that not only test outcomes but also test that certain precondition violations trigger the expected assertion or exception. For example, if a sort function's precondition is "elements must be comparable," test it with non-comparable elements to see if it fails gracefully. This ensures your contracts are really being enforced.  
- **Find the single choice:** If you have repetitive decision logic (like multiple `if type == X` scattered around), introduce a single authority for that decision (like a polymorphic call or a registry of handlers). Make one module the master of that knowledge. This simplifies adding new cases – you add in one place.  
- **Class hierarchy sanity check:** For each inheritance relationship, verify it truly models an is-a. Subclass Liskov check: Every instance of subclass should be usable wherever the superclass is expected without altering correctness. If you find a subclass that violates that (maybe it overrides a method in a way that breaks something), perhaps the hierarchy is wrong. Maybe use composition or rethink the abstraction.  
- **Document the why:** As you code, maintain a small design log or at least comments on tricky sections explaining the rationale. If you had to choose one pattern over another, note the reason. This isn't just for others – it helps you recall your thought process. It's easier to maintain a system that has its reasoning attached.  
- **Regular refactor review:** Periodically (say every sprint or two), take a bit of time to assess if the current design is accumulating debt. Are there contract violations being worked around? Are there many TODOs or FIXMEs indicating design issues? Use that as impetus to refactor or strengthen the design where needed, before it gets worse.

## Key Quotes / Mnemonics

- "Open for extension, closed for modification."  
- "Asking a question should not change the answer."  
- "One and only one module should know all alternatives."  
- *"Design by Contract"* – Correctness through clear obligations and guarantees.  
- *"High cohesion, low coupling."* (Aim for it in every design.)

## "When in doubt" Defaults

- **When in doubt, honor the contract:** If something is uncertain, decide in favor of what preserves or clarifies the contract of your module. It's better to reject an input or throw an exception than to return a possibly wrong result that violates the expected postconditions.  
- **When in doubt, subclass (or add a class) rather than modify:** To implement a new feature, consider adding new subclasses or new methods implementing an interface before changing existing code. This follows Open-Closed by default – extend instead of hack.  
- **When in doubt, separate concerns:** If you're not sure where a piece of code belongs, create a new module or class for it rather than wedging it into multiple existing places. It's easier to integrate a cleanly separated component later.  
- **When in doubt, enforce clarity:** Default to making things explicit and clear. For example, if a certain order of calls is required, don't leave it implicit – either enforce it in code (assert the order) or provide a single method that does the calls in the right order.  
- **When in doubt, keep it simple and correct:** It's better to have a straightforward design that meets today's requirements correctly than an elaborate, overly generic design that might cover tomorrow's use cases at the risk of bugs today. You can generalize when the need actually arises.

## Cross-Reference Notes

- **Relation to DRY (Pragmatic):** Single Choice Principle is a specific application of DRY to decision logic.
- **Relation to SOLID:** Open-Closed is the 'O' in SOLID; Single Responsibility aligns with high cohesion.
- **Relation to Large-Scale Design:** These principles scale up – contracts become API specifications, layers become architectural tiers.

