### rules_pragmatic_programmer.md
#### High-Impact Principles
- **Take responsibility and be proactive:** You have agency in your work – if something is wrong, initiate change or offer solutions (no excuses).  
- **Fix issues early (Broken Windows):** Don’t tolerate small flaws; repair “broken windows” in code to prevent software rot and a culture of neglect.  
- **DRY – Don’t Repeat Yourself:** Eliminate duplication of knowledge in code, documentation, and data. Every piece of information should have a single authoritative representation.  
- **Design orthogonal systems:** Ensure components are independent. Changes in one module should not affect others (loose coupling), and each module has a single well-defined purpose.  
- **Tracer Bullets for development:** Build a thin, end-to-end slice of functionality to get quick user feedback and test your architecture. Use these working prototypes to adjust aim before full implementation.  
- **Prototype to learn:** Create throwaway prototypes (even as simple sketches or mock-ups) to explore uncertain requirements or technologies, but keep production code clean (use prototypes for discovery, not delivery).  
- **Make reversible decisions:** Assume “There are no final decisions” – design with flexibility so you can change course (e.g. swap a module or library) without massive rewrites.  
- **Use plain text and automation:** Keep knowledge (config, data) in plain text for longevity and interoperability. Automate repetitive tasks – write code-generators or scripts to eliminate manual, error-prone work (e.g. Tip: *“Write Code That Writes Code”*).  
- **Invest in your knowledge portfolio:** Continuously learn new languages, tools, and domains. A pragmatic developer is a lifelong learner who diversifies their skills (including communication skills – *“English is just another programming language”*).  
- **Make quality a requirement:** Treat software quality attributes (like reliability, security, performance) as explicit requirements. Decide with stakeholders what level of imperfection is acceptable for quicker delivery (Tip: *“Make Quality a Requirements Issue”*).  
- **Use the right tools and version control:** Master your text editor, debugger, and other tools. Always use version control for your code, no matter how small the project. These practices amplify your productivity and prevent catastrophe.  
- **Test and refactor continuously:** Write tests early to validate behavior, and refactor code when you see duplication or complexity. Small improvements made regularly prevent big problems later.  
- **Communicate and collaborate:** Explain your ideas clearly (remember that writing and speaking are part of a developer’s job). Don’t code in isolation – pair program, seek feedback, and share knowledge for collective code ownership.

#### Antipatterns to Avoid
- **Programming by coincidence:** Don’t write code with a “it somehow works” mindset. Understand *why* your code works; avoid magic and flukes.  
- **Leaving broken windows:** Never ignore known bugs or poor code thinking “I’ll fix it later.” Neglect invites more chaos and debt.  
- **Duplicating logic or data:** Copy-paste coding and parallel implementations violate DRY. Avoid having the same logic in multiple places – it leads to inconsistencies.  
- **Global variables and tight coupling:** Shared mutable state across components creates hidden dependencies. Avoid global data; if something must be widely accessible, wrap it behind an API or access function (no direct global reads/writes).  
- **Making excuses instead of providing options:** Don’t blame external factors or say “it can’t be done” without proposing alternatives. Pragmatic developers offer solutions, not excuses.  
- **Over-engineering (YAGNI):** Adding complexity or features “you aren’t gonna need” is wasteful. Don’t design for unlikely future requirements at the cost of simplicity today.  
- **Ignoring warnings and errors:** Don’t gloss over compiler warnings, failing tests, or error logs. Treat these as actionable signals, not annoyances – they often point to real problems.  
- **Inadequate effort in debugging:** Avoid panic-driven random fixes. Don’t skip the systematic diagnosis of a bug. (E.g. anti-pattern: diving into code changes without reading the error message or understanding the root cause.)  
- **Documentation afterthought:** Not documenting code and decisions is a mistake. Avoid writing code that only you can understand; future maintainers (or you, in a month) will suffer.  
- **“Not my job” mentality:** Don’t silo yourself strictly to your piece. A pragmatic programmer steps up to improve build scripts, deployment processes, tests, etc., rather than saying it’s someone else’s problem.

#### Heuristics & Checklists
- **The DRY check:** Whenever you copy-paste or write similar code, ask if you can refactor to one place. Does every piece of knowledge in your system have a single source of truth?  
- **The Orthogonality test:** After designing a module, verify that it can be changed without affecting others (and vice versa). Do modules interact only through well-defined interfaces?  
- **Before coding a feature:** Plan tracer bullet implementation – identify a thin vertical slice (UI to database, for example) to build first and demo. Ensure you’re building the *right* thing before fleshing it out fully.  
- **Debug systematically:** When a bug arises, *reproduce it* with a minimal test case. Read the entire error message or stack trace. Use the **binary chop** method to narrow down the location (by cutting the problem space in half).  
- **Automate the routine:** If you find yourself performing a manual, repetitive process (build steps, deployments, data setup), script it or use tools. This reduces errors and frees time.  
- **Version control habits:** Commit early and often. Before making experimental changes, take a snapshot (branch or checkpoint) so you can revert if needed. Review diffs before committing to catch mistakes.  
- **Refactoring checklist:** Look for common code smells: long functions, large classes, unclear names, duplicate code, and tightly coupled logic. Refactor in small steps, run tests at each step.  
- **Test early, test often:** Write unit tests for critical code paths. When you fix a bug, add a test to ensure it stays fixed. Use continuous integration so tests run on every commit.  
- **Communication and learning:** After completing a task, ask yourself if you could explain it to a teammate or new developer. If not, your solution might be too complex or insufficiently documented. Also, regularly schedule time to learn new techniques or read on best practices – a pragmatic programmer keeps improving.

#### Key Quotes / Mnemonics
- “Don’t live with broken windows.”  
- “Don’t Repeat Yourself (DRY).”  
- “Fix the Problem, Not the Blame.”  
- “Read the Damn Error Message.”  
- “Don’t Panic.”

#### “When in doubt” Defaults
- **When in doubt, choose clarity:** Favor clear, straightforward solutions over clever but confusing ones. It’s better to write code that is obvious than to save a few lines with a hack.  
- **When in doubt, fix it now:** If you notice a small bug or messy code (“broken window”), address it. Small fixes prevent bigger issues; postponing cleanup only accumulates debt.  
- **When in doubt, do the simplest thing:** Implement the simplest solution that could possibly work. You can iterate from there if needed. Avoid elaborate designs for unproven requirements.  
- **When in doubt, communicate:** Ask for clarification – with your team about requirements or with users about their needs. Don’t sit in confusion; a quick conversation can save hours of wrong work.  
- **When in doubt, take action:** A pragmatic default is to actively improve the situation (write a test, add logging, refactor something small) rather than assuming someone else will handle it. Small positive actions build momentum for quality.

### rules_stroustrup_architecture.md
#### High-Impact Principles
- **Zero-overhead abstraction:** Design abstractions that don’t incur runtime cost for features you don’t use. In Stroustrup’s words, *“What you don’t use, you don’t pay for.”* Aim for implementations as efficient as hand-written low-level code, unless additional cost is justified by clear benefits.  
- **No lower-level escape needed:** A well-designed system shouldn’t require dropping into a lower-level language for performance. C++ was designed so that nothing but assembly can surpass it for efficiency. Likewise, choose tools that let you meet requirements without kludges.  
- **Express ideas directly:** Code should closely model the concepts of the problem domain. Favor clarity and directness in implementation so that someone reading the code sees the intended ideas plainly.  
- **Separate independent concerns:** *“Express independent ideas independently in code.”* Break down functionality so that each module handles a distinct concern. This yields high cohesion and allows changes in one part without ripple effects in others.  
- **Simple ideas, simple code:** Strive to implement simple things in a straightforward way. Don’t convolute a simple task with over-generalized frameworks. Conversely, tackle complex ideas by combining simpler modules in a clear structure.  
- **Composition over inheritance:** Favor building functionality by combining objects (has-a relationships) rather than deep class hierarchies whenever possible. Composition tends to be more flexible and transparent than inheritance for code reuse.  
- **Strong typing for safety:** Leverage the type system (or assertions in dynamic languages) to catch errors early. Design interfaces that make illegal states unrepresentable, and prefer compile-time checks to runtime surprises.  
- **RAII / Deterministic resource management:** Acquire resources (memory, files, locks) in an object’s initialization and release in its destruction. In garbage-collected environments, use context managers or finalizers to ensure timely cleanup. This idiom localizes resource control and prevents leaks.  
- **Minimal and complete interfaces:** Design interfaces with the fewest methods that cover all needed operations for an abstraction. Extra complexity in an API is a liability – each public method should pull its weight. A smaller interface is easier to learn, test, and maintain.  
- **Encapsulation:** Hide implementation details. Users of a module/class should rely only on its public interface. By preventing external access to internals, you make it feasible to change the implementation without breaking other parts of the program.  
- **Use the standard library:** Before custom-coding a data structure or algorithm, check the standard library (or well-vetted libraries). They are likely more optimized and tested. Reinventing the wheel can introduce bugs and technical debt.  
- **Structured error handling:** Use exceptions (or error codes in languages without exceptions) to handle error conditions separately from normal logic. This keeps code cleaner and forces thinking about error states. Ensure that when exceptions occur, resources are released (use RAII or `finally`) and program invariants remain intact.  
- **Multi-paradigm design:** C++ supports procedural, object-oriented, generic (template), and functional styles. Use the paradigm that best fits the task – for example, use object-oriented designs for polymorphic behavior at runtime, and generic programming for efficiency and flexibility at compile time:contentReference[oaicite:30]{index=30}:contentReference[oaicite:31]{index=31}. In any language, don’t be dogmatic about one approach; mix paradigms if it leads to clearer or more efficient design.  
- **Module boundaries and contracts:** Define clear contracts for modules (preconditions/postconditions or at least documentation of responsibilities). Each module or class should have a well-defined role, and it should clearly specify what it expects and guarantees. This clarity helps integration and debugging.  
- **Scalability and adaptability:** Keep in mind the ease of scaling the system up. Whether scaling means handling more load or adding more features, an architecture should have flexibility – e.g., use patterns that allow adding new functionality without modifying existing code (see Open-Closed Principle in OOSC). Design with portability in mind too; avoid needless platform-specific constructs so the code can run in different environments with minimal changes.

#### Antipatterns to Avoid
- **Excessive complexity:** Avoid “clever” code that is hard to understand or maintain. If a solution requires intricate tricks or deep nested logic, consider simplifying the approach. Overly complex designs often hide bugs and deter future changes.  
- **Over-abstraction:** Don’t create class hierarchies or abstractions for their own sake. As Stroustrup notes, over-engineering (too many layers, indirections) can be an “inelegant style” that adds runtime overhead and confusion. Use abstraction to solve real problems, not hypothetical ones.  
- **Global state and singletons:** Uncontrolled global variables or singletons that are used everywhere make the system tightly coupled and context-dependent. They hinder reuse and make testing difficult. Prefer passing needed data as parameters or encapsulating state in objects with well-defined APIs.  
- **Duplication of code or logic:** Repeating code in multiple places (copy-paste programming) is a sign of poor design. It violates DRY and makes fixes or changes error-prone (you must find every duplicate to update). Refactor common functionality into a single module or utility.  
- **Manual resource management errors:** In low-level languages, forgetting to free memory or close files is a common bug. In higher-level settings, failing to release locks or not closing database connections similarly cause issues. Avoid patterns that require a lot of manual try/finally or cleanup code; use constructs that automate this (smart pointers, context managers, etc.).  
- **Ignoring type distinctions:** For example, abusing `void*` in C or extensive casting in C++ undermines type safety. Don’t circumvent the type system without strong justification – it’s there to catch mistakes. In Python, similarly avoid catching exceptions just to ignore type errors; instead write code that naturally works with the expected “duck type.”  
- **Misusing inheritance:** Using inheritance where composition would suffice can lead to rigid designs and the dreaded “inheritance tax.” Don’t derive classes just to reuse code without a true is-a relationship. Also avoid very deep or multiple inheritance hierarchies unless absolutely necessary – they can complicate initialization and understanding of the code.  
- **Premature optimization:** Tuning code for performance before the design is correct and clean can introduce needless complexity. Low-level micro-optimizations (clever caching, unrolled loops, etc.) should not compromise architecture. First ensure the design is clear and correct; optimize later when you have evidence (profiling) of true bottlenecks.  
- **Mixing abstraction levels:** Avoid writing code where high-level logic and low-level details intermingle. For example, performing file I/O (low-level) inside business logic (high-level) without isolation. Separate layers (e.g., use a data access layer, keep GUI code separate from logic) so changes in low-level details don’t force changes in high-level logic.  
- **“Glorified assembly” coding:** Especially in powerful languages like C++, don’t write needlessly low-level code (like manual memory arithmetic or reimplementing data structures) when a higher-level construct would do. If you find yourself doing a lot of pointer math or bit-twiddling in application code, reconsider your approach – you might be prematurely dropping to lower-level than necessary.

#### Heuristics & Checklists
- **Class design checklist:** For each class, can you summarize its purpose in one sentence? Does it have a clear invariant (conditions that should always hold true for any object of the class)? If not, the class might be muddled or doing too much.  
- **Ownership and lifetime:** Examine every resource your code uses (memory, file handles, network sockets). Determine who “owns” it and is responsible for releasing it. Use RAII or similar patterns so that each resource is properly freed exactly once.  
- **Const-correctness (Immutability):** In C++ or similar, mark methods and data as const if they shouldn’t change. In any language, treat immutable data preferentially for values that don’t need to change. This prevents accidental modification and clarifies intent.  
- **Dependency review:** Look at a module’s include/import list. Are all those dependencies truly necessary? Each dependency is a liability (it increases coupling and build complexity). Remove or refactor out unnecessary dependencies (e.g., use forward declarations or dependency injection to decouple implementations).  
- **Interface review:** For each public API, consider misuse scenarios. Is it easy to use correctly and hard to use wrong? If not, maybe introduce safer defaults or split functionality to prevent errors (e.g., separate “init” and “run” steps if calling in wrong order would be catastrophic).  
- **Exception safety audit:** For critical sections, ask what happens if an error/exception occurs. Does the system remain in a valid state? For example, if an exception is thrown, do we leak resources or leave data partially updated? Adjust code to ensure basic exception safety (no leaks, no corruption) at minimum, and strong exception safety (roll back state) where needed.  
- **Use standard tools first:** When you find a need for a particular functionality (sorting, parsing JSON, threading, etc.), check standard libraries or common frameworks before writing your own. A vetted library can save time and prevent bugs.  
- **Polymorphism vs templates vs simple code:** When adding an extension point, decide the mechanism carefully. Could a simple function pointer or strategy object suffice instead of adding a new virtual base class or complex template? Pick the simplest mechanism that achieves flexibility.  
- **Magic numbers and constants:** Scan for raw literals in code. Each “magic number” should become a named constant or be eliminated. This makes code self-documenting and easier to change.  
- **Testing and tooling:** Ensure you have unit tests for modules and use tools (like static analyzers, linters, sanitizers) to catch issues early. In C++, tools can catch memory misuse; in Python, linting can catch type errors. Integrate these into your workflow.

#### Key Quotes / Mnemonics
- “What you don’t use, you don’t pay for.”  
- “Express ideas directly in code.”  
- “Express independent ideas independently in code.”  
- “Express simple ideas simply.”  
- “Leave no room for a lower-level language.”

#### “When in doubt” Defaults
- **When in doubt, favor simplicity:** If torn between a fancy template metaprogramming solution or a straightforward loop, default to the simpler implementation. You can refactor to a more complex solution if profiling shows it’s necessary.  
- **When in doubt, prioritize safety:** Lean towards writing code that is obviously correct and fails visibly if something goes wrong (through assertions or exceptions) rather than something optimized but brittle.  
- **When in doubt, encapsulate:** If you’re not sure whether to expose something (a piece of data or a helper function), don’t expose it. It’s easier to extend an interface later than to take something back. Hide details by default.  
- **When in doubt, use the standard tool:** Default to using language-standard features and library components. They are likely more portable and familiar to other developers. Only deviate if you have a compelling reason (and understand the trade-offs).  
- **When in doubt, get a second opinion:** For tricky architectural decisions, consult a colleague or the community. A fresh perspective can confirm if your simpler approach is acceptable or if there’s a known pattern that fits the scenario.

### rules_python_idioms.md
#### High-Impact Principles
- **Readability counts:** Code is read far more often than it’s written. Optimize for human comprehension even if it means a few extra lines. Python’s design emphasizes that *“Readability counts.”*  
- **Explicit is better than implicit:** Don’t hide meaning or action. Clear, explicit code (even if a bit verbose) is preferred over terse “magic” that’s not obvious to newcomers. For example, be explicit in function arguments and control flow rather than relying on obscure defaults or side effects.  
- **Simple is better than complex:** Given two solutions, choose the simpler design. *“Simple is better than complex. Complex is better than complicated.”* This means solve problems with straightforward approaches and only introduce complexity when absolutely necessary (and even then, manage it).  
- **One obvious way:** There should ideally be one clear way to do something in code (and it should be the preferred idiom). By using common patterns and idioms, you make your code immediately understandable. (Zen: *“There should be one– and preferably only one –obvious way to do it.”*)  
- **Use Pythonic idioms:** Embrace Python’s features for clarity and brevity – e.g., list/dict comprehensions for transforming data, unpacking for clarity, context managers (`with` statements) for resource handling, and generators for lazy data processing. Idiomatic code is typically more readable and concise.  
- **EAFP (Easier to Ask Forgiveness than Permission):** It’s often better to just perform an operation and catch exceptions if something unexpected happens, rather than littering code with checks (LBYL: Look Before You Leap). For instance, call a method and handle an `AttributeError` if an object doesn’t support it, instead of checking types upfront. This leads to cleaner, linear code flow in Python.  
- **Flat is better than nested:** Avoid deeply nested loops or conditionals by refactoring into functions or using loops/ifs in a flat structure when possible. Flat code is easier to follow. For example, use guard clauses to handle edge cases early in a function rather than nesting the main logic in an `if`.  
- **Meaningful naming and simplicity in APIs:** Use descriptive variable and function names to make code self-documenting. Design functions to do one thing well. This aligns with the idea that if implementation or usage “is hard to explain, it’s a bad idea”. Aim for code that communicates intent clearly.  
- **Leverage “batteries included”:** Python comes with a rich standard library – use it. Modules like `logging`, `json`, `sqlite3`, `itertools`, etc., provide tested solutions. Using standard library components yields more robust and maintainable code than custom ad-hoc implementations.  
- **Don’t ignore exceptions – handle or propagate:** Python’s philosophy is that errors should not pass silently. When an exceptional situation occurs, either handle it (log it, recover if possible) or let the exception propagate (so that it’s visible and can be dealt with at a higher level). Never just suppress errors without reason.  
- **Optimize last, if at all:** “Now is better than never. Although never is often better than *right* now.” Write clean, correct code first. Only optimize after profiling shows a need. Python often has high-level constructs that are plenty efficient (e.g., using sum, map, or comprehensions implemented in C). Avoid micro-optimizations that obfuscate code unless you have a proven bottleneck.  
- **Structured data over ad-hoc parsing:** Use Python’s rich data structures (tuples, dataclasses, objects, etc.) to make data relationships clear, rather than, say, packing multiple meanings into a single string or list in ambiguous ways. Code that uses structured data is easier to maintain.  
- **Modular design:** Organize code into modules and packages. Each module should handle a specific area of functionality (e.g., separate data model, business logic, and UI). This makes it easier to reason about and reuse parts of your code. Namespaces (“one honking great idea – let’s do more of those”) prevent name collisions and clarify origin of functions and classes.  
- **Interactive and iterative work style:** Take advantage of Python’s interpreter. Test small pieces of code in the REPL or notebooks. This approach encourages rapid feedback and can inform your design (you discover better APIs by playing with the code).  
- **Embrace the community conventions:** Follow PEP 8 for style (e.g., naming, spacing) and PEP 20 (Zen of Python) for philosophy. These conventions exist to make Python code universally readable and consistent, which is itself a design principle.

#### Antipatterns to Avoid
- **Writing C/Java in Python:** Don’t use overly verbose or low-level patterns that are unnecessary in Python (e.g., manual memory management, or writing loops where a vectorized library call or comprehension would be clearer). Embrace Python’s dynamic and high-level nature; avoid unnecessary boilerplate.  
- **Mutable default arguments misuse:** Never use a mutable object (like a list or dict) as a default parameter value for a function. It can lead to surprising behavior (the default persists across calls). This is a common Python pitfall – use `None` and inside the function initialize a new object if needed.  
- **Overusing type checks and casting:** Avoid peppering code with `isinstance()` or type-check conditions to enforce types. This goes against duck typing. Instead, write functions that operate on a protocol (set of methods/attributes). Only use explicit type checks when absolutely required (for example, to prevent an unsafe operation or to distinguish two very different acceptable types).  
- **Catching broad exceptions blindly:** A bare `except:` (or catching `Exception` without good reason) that just passes or hides the error is an anti-pattern. It silences issues and makes debugging nightmares. Catch only exceptions you expect and know how to handle; at the very least log unexpected exceptions with traceback.  
- **Deep nesting and long functions:** If you have deeply nested code (many levels of `if/for/try` inside each other), it’s likely too complex. This can often be refactored by splitting into smaller functions or using loops/ifs in sequence. Similarly, very long functions (hundreds of lines) usually indicate it should be broken up.  
- **Premature micro-optimizations:** Avoid tricks like manually inlining loops, caching variables in local scope for speed, or using bit-twiddling hacks unless you’ve proven the code’s too slow and these make a measurable difference. Such code is harder to read and often not necessary thanks to improvements in Python’s interpreter and libraries.  
- **Ignoring Pythonic conventions:** For instance, not using context managers for resource cleanup (and instead using try/finally everywhere), or not using `with open(...) as f` for files. These conventions exist to handle common tasks safely; ignoring them can lead to errors (like forgetting to close files).  
- **Reinventing the wheel:** Don’t write your own object-relational mapper, web server, templating system, etc., without checking existing solutions. Reusing robust library code is usually better. Custom solutions tend to be less tested and divert focus from your core problem.  
- **Global variables for configuration/state:** Relying on module-level globals that many functions modify/read is dangerous. It makes the code order-dependent and hard to track. Instead, pass parameters, use class attributes, or encapsulate state in objects.  
- **Mixing concerns:** Avoid writing functions that do too many unrelated things (e.g., processing user input, performing calculation, and printing output all in one). Separate concerns: logic vs I/O vs presentation. This makes code more testable and flexible.  
- **Neglecting documentation and tests:** Not writing docstrings for public functions/classes and not writing tests for complex logic are antipatterns. It may not affect the code’s runtime behavior, but it certainly affects maintainability and robustness. Skipping these is a design smell indicating fragile or developer-hostile code.

#### Heuristics & Checklists
- **Zen compliance check:** After writing a module or function, mentally (or literally) go through the Zen of Python aphorisms. Is anything too implicit or obscure? Could it be simpler? Is the code complex where a simpler approach exists? This can be surprisingly effective in spotting design issues (e.g., a function that is doing too much).  
- **Standard library first:** Before coding a solution, scan the Python standard library or well-known packages. For example, need to parse XML? Try `xml.etree`. Need to time something? Use `timeit` or `profile`. There’s a good chance Python already provides the tool you need.  
- **Idiomatic code check:** Look at your loops and conditionals. Are you using Python idioms? e.g., `for idx, val in enumerate(my_list)` instead of a manual index, or `for key, val in mydict.items()` instead of iterating over keys then indexing the dict. Use list comprehensions or generator expressions for simple transformations instead of accumulating in a loop – but also ensure they remain readable and not overly complex.  
- **Exception handling checklist:** When catching exceptions, ask: *What will I do with this exception?* If the answer is “nothing” (i.e., just pass), that’s usually wrong – either remove the handler so it fails visibly, or handle it (log, retry, etc.). If you do handle it, consider using the `logging` module to record the full traceback and error for later debugging.  
- **Function length and responsibility:** Each function should ideally do one thing. If you find yourself writing comments like “# step 1”, “# step 2” inside a function, that’s a hint it could be split into multiple functions. Similarly, if a function requires a lengthy docstring to explain, maybe it’s doing too much.  
- **Data structure choice:** Use Python’s rich data structures appropriately. For instance, use a dictionary for lookups by key (instead of scanning a list), use a tuple to represent an immutable sequence, or a namedtuple/dataclass for a record with named fields. The right choice makes code more self-explanatory and often more efficient.  
- **PEP 8 style audit:** Run a linter or formatter. Check that names are descriptive (`calculate_area` vs `calcA`), constants are uppercase, classes are CapWords, etc. Consistent style reduces cognitive load for readers.  
- **Unit test coverage:** Ensure that critical modules have unit tests. As you fix bugs, add tests to cover them. Tests not only catch regressions, they also serve as usage examples and thereby documentation for your code’s behavior.  
- **Performance check (when needed):** If performance is a concern, use the right tools: e.g., profile your code with `cProfile` to see where the time is going. Often, a small hotspot can be optimized or a library function can replace Python loops. Optimize based on evidence, not guesswork.  
- **Documentation and examples:** For any module or complex function, check if you’ve provided examples or clear explanation in the docstring. If someone else imported your module and ran `help(your_module)` or `help(your_class)`, would they quickly grasp how to use it? If not, improve the docstring to include a usage blurb.

#### Key Quotes / Mnemonics
- “Explicit is better than implicit.”  
- “Simple is better than complex.”  
- “Readability counts.”  
- “Errors should never pass silently.”  
- “There should be one… obvious way to do it.”

#### “When in doubt” Defaults
- **When in doubt, choose clarity:** If you’re unsure about a piece of code, err on the side of writing it in the clearest way (even if it’s slightly longer or less “clever”). Future maintainers will thank you.  
- **When in doubt, make it explicit:** Don’t assume others (or the computer) will infer what you mean. Spell it out – whether in code structure, parameter names, or control flow. For example, if a function does something non-obvious, consider splitting it or adding a comment.  
- **When in doubt, use the standard approach:** Follow the principle of least surprise. Use common Python idioms and patterns so that other Python developers can immediately recognize what your code is doing. If you’re not sure, doing it “the usual way” is a safe default.  
- **When in doubt, let errors be known:** It’s better to raise an exception or log an error than to soldier on in ambiguity. If a situation is ambiguous or unexpected (e.g., a function got an input it doesn’t support), default to failing fast with an error – *“In the face of ambiguity, refuse the temptation to guess.”*  
- **When in doubt, keep it simple:** Apply Occam’s razor to your code. A simpler solution that’s easy to understand is preferable as a default. Only introduce complexity (like additional layers of abstraction, concurrency, metaprogramming, etc.) if a straightforward solution truly won’t suffice.

### rules_oosc.md
#### High-Impact Principles
- **Design by Contract (DbC):** Define precise **contracts** for software elements – each module or method should have clear preconditions (what it expects), postconditions (what it ensures), and invariants (what always holds true). By making these explicit, you catch errors early and build more reliable software. The code should actively check critical assumptions (using assertions) during development to prevent bugs from going silent.  
- **Open-Closed Principle:** Software entities (classes, modules, functions) should be **open for extension** but **closed for modification**. In practice, this means design your system so you can add new functionality by adding new code (e.g., subclasses, new functions) rather than changing existing code. This leads to more stable and maintainable code, because existing, tested code isn’t being constantly tweaked when requirements change.  
- **Command–Query Separation (CQS):** *“Asking a question should not change the answer.”* Every method should be either a **command** (performs an action with side effects) or a **query** (returns data, without side effects), but not both. This separation makes code easier to reason about – you can call queries freely without worrying they will modify state, and commands clearly stand out as operations that change state.  
- **High cohesion, low coupling:** Aim for *high cohesion* (each module/class has one well-defined purpose and its elements are strongly related) and *low coupling* (minimal dependencies between modules). A design with high cohesion is easier to understand and reuse, and low coupling means changes in one place have little impact elsewhere. These principles underlie many of Meyer’s recommendations (e.g., modularity, single responsibility, etc.).  
- **Single Choice Principle:** Avoid duplicating the knowledge of alternatives across the system. *“Whenever a system must support a set of alternatives, one and only one module should know their exhaustive list.”* In other words, if you have a set of variants (say, handling multiple file formats or transaction types), centralize the decision of which variant to use in one place (like a factory or strategy) rather than scattering conditionals throughout the code. This prevents inconsistency and makes extending alternatives easier (you update one module).  
- **Uniform Access Principle:** Whether a client is obtaining data from memory or computing it on the fly should not affect how it’s accessed. In OOSC terms, accessing an attribute or invoking a parameterless method should look the same. This principle encourages encapsulation: you can change a field to a computed property without impacting callers. (In Python, properties and in C++/Java, use of getters hide implementation; in Eiffel, attribute access and function call use identical syntax.)  
- **Defensive Design vs. Contractual Design:** Meyer advocates a contractual approach – a routine is responsible for its postcondition if callers meet the precondition. This means don’t overly defensive-check things that the contract says should be true (it can hide bugs). Rely on contracts: the caller ensures preconditions, the routine guarantees postconditions. Use assertions to make sure contracts are not violated during development.  
- **Robustness through controlled exceptions:** When contracts are broken (an unexpected situation), handle it in a defined way. For example, if a routine cannot fulfill its contract, it should signal an exception. OOSC suggests exceptions be used for contract violations and truly abnormal cases, not for normal flow. Also, a module catching an exception should know how to recover or else propagate it – don’t catch and ignore.  
- **Extendibility and reusability:** Design classes and modules that can be extended or reused in new contexts. This often means abstracting the general concept from the specific. For instance, if you find two similar classes, consider extracting a common base class or utility functions. However, ensure the abstraction is valid; don’t force reuse via inheritance where composition or simple functions might be clearer.  
- **Methodological consistency:** Follow a consistent methodology for analysis and design. In OOSC, Meyer lays out steps from analysis to design to implementation. Sticking to a method (like carefully identifying classes and their contracts before coding) leads to more thought-out designs. Ad-hoc design can work for small scripts but not large systems.  
- **Quality focus:** Always consider software quality factors – **correctness, robustness, extendibility, reusability** – during design. For example, ask yourself: Is this design easy to extend for future requirements (open-closed)? Will it be reusable in other projects or contexts? How will it behave if given bad inputs (robustness)? And, foremost, does it fulfill the specifications exactly (correctness)? Balancing these concerns yields well-engineered software.  
- **Avoiding redundancy:** Don’t allow the same knowledge to exist in multiple places (a nod to DRY, which aligns with Meyer’s Single Choice principle). This applies to code, but also to things like documentation vs. code – generate documentation from code or vice versa to ensure there’s a single source of truth.  
- **Clear abstraction layers:** Structure your system in layers (or tiers) where each layer has a well-defined responsibility. Upper layers use services of lower layers but not vice versa. For example, a GUI layer might use a domain logic layer, which in turn uses a data access layer. This layering (similar to the idea of *“onion architecture”* or *“rings”* mentioned in OOSC) ensures changes in one layer (like swapping a database) have limited impact.  
- **Polymorphism over conditionals:** Use polymorphism (inheritance or interface implementations) to handle variations in behavior rather than big if/else or switch statements scattered in code. For instance, instead of an if chain checking types, have each type implement a method in a class hierarchy. This ties in with open-closed: adding a new type then just means adding a new class, not modifying a bunch of conditional logic.  
- **Document and justify decisions:** OOSC encourages not just doing things right, but also recording why a certain design decision was made (especially if it’s complex). Key design decisions, assumptions, and contract rationales should be documented. This helps future maintainers (and yourself) understand the constraints of the design.

#### Antipatterns to Avoid
- **Mixing commands and queries:** Do not write methods that both modify state and return a useful result. This ambiguity can lead to unexpected side effects and confusion (violation of CQS). For example, a method `balance.withdraw(amount)` that returns the new balance *and* changes it is worse than separate `withdraw` (command) and `get_balance` (query).  
- **Violating Liskov Substitution (LSP):** LSP (related to OCP) means subclasses should be usable anywhere the base is expected. Antipatterns include overriding a method and *narrowing* the specification (e.g., stronger precondition or weaker postcondition), which breaks substitutability. Don’t surprise clients: if class B inherits A, any behavior guaranteed by A must hold in B too.  
- **Overly defensive coding against the contract:** For instance, checking for null or validating parameters inside a method when your design’s contract says the caller shouldn’t pass null. This clutters code and can mask contract violations. Instead, use assertions to document the precondition but not code to silently correct it – a failure should be detected during testing.  
- **Exception misuse:** Using exceptions for flow control (e.g., using try/except to break out of loops instead of proper loop constructs) or swallowing exceptions completely (`try: ... except: pass`) are bad practices. This goes against the idea that exceptions signal something exceptional. Catch exceptions at a level that can do something about them, or let them propagate.  
- **God classes / too many responsibilities:** Avoid classes that know too much or do too much (often called “God classes” or high coupling hubs). In OOP, this violates cohesion and modularity. For example, a class that manages UI, database, and business logic all together is an antipattern – such a class is hard to reuse or maintain.  
- **Parallel class hierarchies:** A sign of poor design is needing to update multiple class hierarchies for one concept change (e.g., you have `CarUI`, `CarLogic`, `CarDB` classes in separate hierarchies that all must be modified to add one feature for “Car”). Instead, co-locate related functionality or use composition to avoid this duplication of structure.  
- **Multiple inheritance misuse:** While multiple inheritance can be powerful (as in Eiffel, which Meyer designed), it can also create complexity (the diamond problem). Avoid multiple inheritance unless you truly need to model something that inherently has two types of “is-a” relationships and your language handles it safely. Prefer interfaces or mixins (which contain no state) or composition to simulate multiple facets if possible.  
- **Fat interfaces / classes:** An interface (or class) that has too many methods is hard to implement and mock, and indicates it might be doing too much. Don’t require users to implement methods they may not need. Breaking interfaces into smaller ones (interface segregation principle) or classes into smaller collaborators can improve this.  
- **Undocumented assumptions:** If your module assumes something (e.g., a function must be called after another, or a global setting must be in place), it’s an antipattern to not make that explicit. Unstated assumptions lead to bugs when someone else (or you later) use the code incorrectly. Document or enforce assumptions via contracts or code.  
- **Global mutable state:** OOSC Chapter 18 discusses global objects and constants. Mutable globals (like a global list that various parts of the program modify) are dangerous – they introduce non-local effects and ordering issues. Avoid them; if you need a global, make it constant or restrict access tightly (perhaps via accessor functions that enforce invariants).  
- **Duplicated code paths:** If two different modules implement nearly the same logic in slightly different ways, that’s an antipattern. It often happens when there is no Single Choice principle – e.g., multiple modules know about all file format types and each has a switch over them. Consolidate such logic to one place to avoid divergence and bugs.  
- **Ignoring quality factors:** Don’t design only for happy-path functionality while ignoring correctness, robustness, etc. For example, not handling erroneous input at all, or not considering how the design will scale with more features, will haunt you. Avoid a design that only works in ideal conditions but is brittle in real-world use.

#### Heuristics & Checklists
- **Contract completeness check:** For each class or major function, explicitly list its preconditions, postconditions, and invariants (even informally, in comments or a notebook). Have you covered normal cases and edge cases? If something isn’t clear in the contract, refine it. During code reviews, discuss contracts – does the implementation fulfill its promises and assume its prerequisites?  
- **OCP question:** When implementing a change request or new feature, ask “Could I implement this by adding new code rather than changing existing code?” If yes, try to do so (e.g., add a new subclass or new method). If you find you must modify a lot of existing code for a minor extension, it’s a sign the design might need refactoring towards Open-Closed (maybe introduce an abstraction).  
- **CQS audit:** Look through your class APIs – are any getters doing hidden modifications? Are any commands returning something that suggests they should be split? Adjust methods to be one or the other. For example, if `update_and_get_status()` both changes state and returns info, consider splitting that into `update()` and `get_status()`.  
- **Single Responsibility check (cohesion):** Can you describe what each module is responsible for in one sentence without using “and”? If you catch yourself saying “Module X does A and B,” consider if A and B are separate enough to be in different modules. High cohesion means each piece does one thing well.  
- **Coupling check:** Examine inter-module dependencies. Draw a quick diagram. If everything depends on everything, that’s a red flag. Try to introduce intermediate abstractions or decouple via interfaces. If module A and B call each other (cycle), break that by introducing an interface or moving functionality so the dependency goes one way only.  
- **Exception policy:** Decide how your system handles errors: which layer catches which exceptions? Ensure that lower-level exceptions are either translated to higher-level ones or allowed to bubble up. Document this. A good heuristic: only catch an exception if you can either *fix* the problem or *translate* it to something the caller of your component would understand. Otherwise, let it propagate.  
- **Testing and DbC:** Write unit tests that not only test outcomes but also test that certain precondition violations trigger the expected assertion or exception. For example, if a sort function’s precondition is “elements must be comparable,” test it with non-comparable elements to see if it fails gracefully. This ensures your contracts are really being enforced.  
- **Find the single choice:** If you have repetitive decision logic (like multiple `if type == X` scattered around), introduce a single authority for that decision (like a polymorphic call or a registry of handlers). Make one module the master of that knowledge. This simplifies adding new cases – you add in one place.  
- **Class hierarchy sanity check:** For each inheritance relationship, verify it truly models an is-a. Subclass Liskov check: Every instance of subclass should be usable wherever the superclass is expected without altering correctness. If you find a subclass that violates that (maybe it overrides a method in a way that breaks something), perhaps the hierarchy is wrong. Maybe use composition or rethink the abstraction.  
- **Document the why:** As you code, maintain a small design log or at least comments on tricky sections explaining the rationale. If you had to choose one pattern over another, note the reason. This isn’t just for others – it helps you recall your thought process. It’s easier to maintain a system that has its reasoning attached.  
- **Regular refactor review:** Periodically (say every sprint or two), take a bit of time to assess if the current design is accumulating debt. Are there contract violations being worked around? Are there many TODOs or FIXMEs indicating design issues? Use that as impetus to refactor or strengthen the design where needed, before it gets worse.

#### Key Quotes / Mnemonics
- “Open for extension, closed for modification.”  
- “Asking a question should not change the answer.”  
- “One and only one module should know all alternatives.”  
- *“Design by Contract”* – Correctness through clear obligations and guarantees.  
- *“High cohesion, low coupling.”* (Aim for it in every design.)

#### “When in doubt” Defaults
- **When in doubt, honor the contract:** If something is uncertain, decide in favor of what preserves or clarifies the contract of your module. It’s better to reject an input or throw an exception than to return a possibly wrong result that violates the expected postconditions.  
- **When in doubt, subclass (or add a class) rather than modify:** To implement a new feature, consider adding new subclasses or new methods implementing an interface before changing existing code. This follows Open-Closed by default – extend instead of hack.  
- **When in doubt, separate concerns:** If you’re not sure where a piece of code belongs, create a new module or class for it rather than wedging it into multiple existing places. It’s easier to integrate a cleanly separated component later.  
- **When in doubt, enforce clarity:** Default to making things explicit and clear. For example, if a certain order of calls is required, don’t leave it implicit – either enforce it in code (assert the order) or provide a single method that does the calls in the right order.  
- **When in doubt, keep it simple and correct:** It’s better to have a straightforward design that meets today’s requirements correctly than an elaborate, overly generic design that might cover tomorrow’s use cases at the risk of bugs today. You can generalize when the need actually arises.

### rules_large_scale_design.md
#### High-Impact Principles
- **Layered, hierarchical design:** Organize code into *layers* (levels) where each module or package at level N depends only on those at lower levels (N-1, N-2, etc.). This produces a directed acyclic dependency graph and clear separation of concerns. Higher-level policies and business logic reside at the top, while low-level utilities and foundations are at the bottom.  
- **Acyclic dependencies (no cycles):** Ensure the dependency graph of components has no circular dependencies. Cycles make reasoning, testing, and building the system much harder (you can’t compile or understand one component in isolation). If you detect a cycle, refactor by introducing an interface or an intermediate module to break the loop.  
- **Small, cohesive components (physical units):** Use *components* as the atomic unit of code release and reuse. In C++ terms, John Lakos suggests one class or cohesive cluster of functionality per component (often one .h/.cpp pair). In any language, think of components as modules/packages that encapsulate a single concept. This granularity allows independent development and testing of each piece.  
- **Explicit packaging and levels:** Group related components into packages (or libraries), and assign a level number to each package to indicate its position in the dependency hierarchy. E.g., Level 0 might be low-level utilities, higher levels build on those. A package should only depend on packages of lower (more fundamental) level. This disciplined approach prevents “spaghetti” linkage between parts of the system.  
- **Stable interfaces, evolve internals:** Treat published interfaces of components as contracts that remain stable for clients. Internally, you can iterate and improve, but keep the external behavior/backward compatibility as much as possible. This allows other teams to use your component without fear of it breaking frequently. When changes to interface are needed, batch them or provide migration paths.  
- **Reuse before buy/build:** Reuse isn’t just a buzzword – it’s an economic necessity in large systems. *“Every attempt must be made to use existing libraries.”* Before writing new code, look into your organization’s library of components or well-regarded external libraries. It’s often faster and safer to integrate a tested component than to create and debug a new one from scratch.  
- **Code as an asset (Software capital):** Treat your codebase as a long-term asset rather than disposable. Good design and modularity are investments that pay off as the codebase grows. *“Software should be treated as an asset… rather than an expense…”* – meaning time spent structuring code well yields returns in easier maintenance and extension. Encourage a culture of building components that can be leveraged across projects (not quick hacks that solve only the immediate problem).  
- **Balance reusable vs. collaborative code:** Not every piece of code needs to be a generic library. It’s fine to have modules that are *collaborative* (specific to one application but broken into components for that app’s sanity) rather than fully reusable elsewhere. Identify core functionalities that are common and factor those into reusable components, but keep application-specific logic separate. This avoids over-engineering everything for reuse when only some parts benefit from it.  
- **Physical design matters:** The arrangement of source files, libraries, and build dependencies is crucial. Slow build times or complicated link dependencies can sap productivity. Strive for *fast, independent compilation units* – if a change in one component triggers recompilation of a huge portion of the codebase, re-examine dependencies. Use forward declarations, minimal includes, and dependency inversion to cut build coupling.  
- **Independent development and testing:** Each component (or small package of components) should be testable on its own, ideally with a dedicated test driver or unit tests. This encourages parallel development (teams can work on different components with well-defined interfaces) and easier debugging (you can localize faults to a specific component).  
- **Facades and dependency control:** Use facade patterns or API gateways between subsystems. For example, if a high-level module needs data from a lower subsystem, instead of depending on many modules of that subsystem, depend on a single Facade class or interface. This limits the points of contact and makes it easier to swap out implementations or make large changes in one part without breaking others.  
- **Levelization and incremental growth:** When adding new features, integrate them at the appropriate level. If a new feature cuts across layers, consider factoring some logic into a lower layer so higher-level parts remain unaffected. Over time, continuously *levelize* – push generic utilities downwards into common libraries, and keep domain-specific logic upward. This process gradually yields a robust layered architecture.  
- **Visibility control:** In large codebases, controlling what is exposed is important. Use language features (like `internal` or non-exported symbols, or Python’s `_` convention) to limit the visibility of internal module details. This prevents unwarranted coupling because other modules can’t depend on things they’re not supposed to see.  
- **Naming and organization:** Establish clear naming conventions for packages, modules, and components that reflect the layering. For instance, you might prefix low-level utility components with `base_` or put them in a `base` package. This provides a quick visual cue of a component’s level and intended use.  
- **Continuous architecture governance:** As the system evolves, periodically review the dependency structure. Tools can analyze include/import graphs to identify cycles or growth in undesirable directions. Make architecture a part of the definition-of-done: code that would introduce a cycle or inappropriate dependency should be refactored before merge. This vigilance keeps the design from degrading under schedule pressure.

#### Antipatterns to Avoid
- **Cyclic dependencies:** Any form of cyclic dependency between modules or packages is a big no-no. It indicates poor partitioning. Avoid mutual inclusion or import loops. If two components absolutely need each other’s functionality, consider merging them into one, or better, introduce an interface to break the cycle (have one component depend on an abstract interface that the other implements, rather than directly on the implementation).  
- **“Big ball of mud”:** A system where everything depends on everything (no clear structure) is an architecture antipattern. If adding a tiny feature requires touching code in many places all over the system, that’s symptomatic of this. Avoid it by adhering to layering and proper separation. Anytime you sense the architecture dissolving into entanglement, step back and refactor.  
- **Monolithic mega-modules:** Don’t create modules that lump too many responsibilities (e.g., a single `Utils` module that has 500 unrelated functions). Such modules become dumping grounds and create excessive rebuild dependencies. Break them into coherent submodules. Similarly, overly large libraries (~thousands of classes) that everyone must link against can slow builds and cause unwanted coupling – consider splitting along functional lines.  
- **Copy-pasted code across codebase:** In a large system, it’s easy for duplicate code to sprout (two teams solving the same problem in different areas). This leads to inconsistent behavior and maintenance overhead. Avoid this by actively encouraging reuse and communication – have a searchable repository of components, and promote a culture of “if it exists, use it; if not, create it for all.” If you find copy-paste, consolidate it.  
- **Upward dependencies:** Lower-level utilities should not depend on higher-level modules. For example, a math library should not import from a GUI module. Such inverted dependencies create cycles and weird coupling. Use dependency inversion (where a high-level module defines an interface and the low-level module implements it) if a lower layer needs to callback or communicate upward. This keeps compile-time dependencies one-way.  
- **Poor physical separation:** If your source code organization doesn’t reflect logical structure (e.g., all files dumped in one directory, or naming not indicating layering), it’s an antipattern. It makes it hard for new developers to find things and understand boundaries. Each top-level component or layer should correspond to a directory or identifiable prefix.  
- **Lack of internal boundaries (“mini-architectures”):** In large applications, each subsystem might need its own internal structure. An antipattern is treating a huge subsystem as a monolith internally. Instead, apply the same principles of layering and modularity *within* subsystems. If not, those subsystems become unmanageable and can’t be worked on by multiple teams effectively.  
- **Reinventing instead of refactoring:** When faced with a system that’s hard to change, a common antipattern is to *rewrite or add parallel implementations* rather than refactor the existing design (because it seems too hard). This leads to duplicate systems (say, two JSON parsers in the codebase) and confusion. It’s better to invest in improving the existing component (or replacing it wholesale but one component at a time) than piling on redundant functionality.  
- **Neglecting build system impact:** In C++ large scale, including one header too many can blow up compile times. In any language, having enormous modules can slow incremental builds or deployments. Don’t ignore the signals: if build or start-up times grow, address architecture (split modules, use lazy-loading, etc.). It’s an antipattern to say “we’ll just throw hardware at it” once build times or binary sizes become a problem; instead, fix the root cause in design.  
- **No clear ownership:** In large projects, if no one knows which team or person owns a component, that component can become a bottleneck or fall into disrepair. Ensure that each module or subsystem has a clear owner or owning team. Lack of ownership is an organizational antipattern that affects technical quality. Without an owner, code might be modified inconsistently or not at all when needed.  
- **Permissive dependency policies:** If developers can depend on any module arbitrarily with no review, the architecture can degrade. Avoid the antipattern of having no rules or checks on dependencies. Instead, enforce guidelines (e.g., via code reviews or even automated dependency checks) so that you don’t suddenly find a high-level UI module depending on a low-level utility in a backward way, or two features mutually depending on each other’s internals.

#### Heuristics & Checklists
- **Draw the dependency graph:** Periodically, visualize the module dependency graph (there are tools to generate this). Verify it’s acyclic and roughly layered. If you see a cycle or a surprising dependency edge (module A depending on something far out of its expected layer), flag it for refactoring.  
- **Review changes for layering:** In code reviews, include an “architecture check”. If a change introduces a new dependency (import/include) on a module that seems out of layer or context, question it. It’s easier to correct a bad dependency when it’s introduced than to unravel it later.  
- **One class per component guideline:** In C++ Lakos suggests one class per .h/.cpp. As a checklist item, if a component file grows to contain many classes or responsibilities, consider splitting it. In higher-level languages, if a single module (file) has many unrelated functions or classes, break it into multiple modules. Keep physical components manageable and focused.  
- **Component test:** Does each component have a test driver or suite? If not, it might be too entangled to test on its own, which indicates high coupling. Aim to write a small test (or even a `main` function or REPL script) that instantiates and uses the component in isolation to verify it works. This is both a design and quality check.  
- **Include what you use (and no more):** For C/C++: each file should include only the headers it directly needs, not relying on indirect includes via other headers. This reduces build times and coupling. In other languages, similarly ensure you only import what you actually use. This discipline prevents unintended tight coupling.  
- **Search for duplicates:** Use tools or scripts to scan for similar code or functions with similar names. If two implementations look similar, unify them. A large codebase can accidentally accumulate redundant code – proactively seek and destroy duplication.  
- **Monitor build metrics:** Keep an eye on build times, binary sizes, cycle times. When a metric spikes, treat it like a code smell. For instance, if a minor code change triggers a rebuild of 1000 files, investigate why – maybe a frequently included header includes too much, or a popular module has grown too entangled.  
- **Encourage modular thinking:** In planning meetings or design discussions, frame work in terms of modules: “What new components do we need?”, “Can we extend component X to do this?”, “Which layer should this functionality live in?” This mindset helps developers naturally gravitate to solutions that fit the architecture, rather than piling on hacks.  
- **Refactoring budget:** Allocate time in each release or sprint for architectural maintenance. For example, resolving a cycle, splitting a large module, or simplifying dependencies. If you treat architecture fixes as part of regular work (instead of only doing features), you prevent big issues later.  
- **Document the architecture:** Maintain a high-level system diagram and a brief text describing the roles of major subsystems and their layering. Keep it updated (maybe in a README or wiki). This helps onboarding new developers and also serves as a guide for keeping the architecture coherent. If the code and the documentation start diverging, it’s a sign architecture erosion might be happening.  
- **Cross-team API reviews:** If one team provides a library or service for others, have a design review of that API involving consumers. This ensures the component boundaries are sound and the dependency will be easy to use and stable. It’s cheaper to adjust an interface before multiple components depend on it.  
- **Graceful deprecation plan:** In large systems, you’ll replace or upgrade components over time. Have a strategy for deprecating old components (mark them, provide alternatives, eventually remove). Avoid the antipattern of keeping dead code or parallel systems forever. A clean retirement of modules keeps the system lean.

#### Key Quotes / Mnemonics
- “Dependencies among packages should form a partial order (no cycles).”  
- “A package at Level N should depend only on packages at Level N-1.”  
- “Software modules must have an acyclic dependency graph.”  
- “Every attempt must be made to use existing libraries.”  
- “Software should be treated as an asset, not an expense.”

#### “When in doubt” Defaults
- **When in doubt, enforce boundaries:** Default to disallowing a questionable dependency or coupling. It’s better to require an extra step (like creating an interface or moving some code) than to allow a shortcut that breaks architecture. Say “no” first to shortcuts that violate layering; find a more architecture-compliant solution.  
- **When in doubt, make a new module:** If a piece of code doesn’t clearly belong in an existing component, create a new one for it rather than squeezing it in improperly. New components are cheap; architectural messes are expensive.  
- **When in doubt, reuse rather than reimplement:** If you suspect functionality exists elsewhere in the system or in a library, take the time to search for it. It’s often faster to adapt an existing solution than to write, debug, and integrate a new one.  
- **When in doubt, keep it independent:** Write code as if it might be moved out into a library later. That means minimize external dependencies, keep functions pure where possible, and isolate hacks. This way, your code is more modular by default.  
- **When in doubt, maintain stability:** Avoid drastic changes to widely-used interfaces without a very good reason. If you’re uncertain, preserve backward compatibility. It’s usually better to add new functions or flags (to extend) than to change existing behavior in-place. Stability builds trust in the structure of a large codebase.

### rules_debugging_mode.md
#### High-Impact Principles
- **Fail fast, fail loud:** It’s better for software to crash or raise an error when something goes wrong than to silently continue in a corrupted state. Use assertions and sanity checks to catch impossible conditions immediately. In production, crashing with logs or error reports is often preferable to “random” wrong behavior – you get a clear signal that something needs fixing.  
- **Instrumentation and observability:** Build in logging, metrics, and tracing from the start. A well-placed log (at INFO or DEBUG level) can save hours when diagnosing an incident. *“Saving tracebacks to a log file can make it easier to debug problems… hard to reproduce… in production.”* Use structured logging and include context (identifiers, timestamps, etc.) so you can trace what happened when things go wrong.  
- **Reproduce issues systematically:** When a bug appears, make it your goal to reproduce it reliably. *“Reproduce it!”* – find a minimal set of steps or a data sample that triggers the bug every time. Once you can do that, you have a golden key to debug: you can experiment and know if you’ve fixed it. If the bug cannot be reproduced easily, enhance logging or add debug modes to gather more info next time.  
- **Stay calm and methodical:** In a fire-fight (production outage, big bug), the worst thing is to panic or thrash. Take a deep breath and make a plan. *“Don’t Panic.”* Instead of making random changes, systematically narrow the problem. Use binary search through configurations or code (disable half the features to see if the bug remains, then narrow down). This analytical approach prevents injecting new errors under duress.  
- **Root cause, not symptoms:** Keep asking “why” until you get to the fundamental cause of a bug. For example, don’t stop at “X was null and caused a crash; I’ll just add a null-check.” Ask why X was null – was there an earlier logic error or unexpected input? Aim to fix that root cause. *“Fix the problem, not the blame.”* – focus on the technical issue, not whose fault it was. After solving, consider writing a test to cover this scenario in the future.  
- **Prepare for “impossible” cases:** If you ever think “this bug is impossible,” remind yourself that the software is telling you otherwise. Accept that something unexpected happened and use that as a clue. Sometimes the bug is in an assumption you believed was infallible. In design, include safety nets: e.g., default cases in switches, else clauses, or error handlers for states you “think” are impossible – just in case. They can always alert if truly never reached.  
- **Leverage debugging tools:** Use interactive debuggers (like `pdb` in Python, or IDE breakpoints) to inspect state at runtime. A debugger lets you pause the program at the right spot and examine variables, step through code line by line, and truly *see* what is happening. This can be far more efficient than adding dozens of print statements. In production, tools like error monitoring dashboards or remote debuggers can be invaluable to peek at a live system’s state (with care for performance and security).  
- **Minimal invasive “surgery” in prod:** If you must apply a quick fix directly in a production environment (e.g., a hotfix or a manual data correction), keep it as surgical as possible. Change the minimum necessary and document exactly what was done. Ideally, feature-flag problematic sections off. This reduces the risk of the fix causing more issues. Then, as soon as possible, follow up with a thorough fix via the normal development pipeline.  
- **Design for debugging:** Write code and design systems with debuggability in mind. For instance, assign correlation IDs to requests so you can trace a single transaction through logs, or design state machines such that they can dump their current state easily. If a module is complex, provide a debug interface or verbose mode. Simple things like meaningful error messages (including context like which user or data caused an error) go a long way in production troubleshooting.  
- **Post-mortem culture:** After a major bug or outage, do a *post-mortem*. Gather what happened, how it was fixed, and how to prevent it. This is not for blame, but for learning. Often this leads to action items: improve monitoring here, add a test there, adjust the process somewhere else. Over time, this practice drastically improves software reliability and team expertise.

#### Antipatterns to Avoid
- **Ignoring the obvious signals:** Don’t disregard error messages, stack traces, or alerts. The program often tells you what’s wrong (*exception message, error code, log entry*). For example, skipping over an exception’s text is a missed opportunity – always **“Read the Damn Error Message.”** Many bugs can be solved by carefully reading and understanding the first error that occurred.  
- **Scattershot guessing:** Avoid the habit of randomly changing code or configurations hoping the bug goes away. This “shooting in the dark” may hide the symptom without addressing cause, or introduce new bugs. Each change should be hypothesis-driven: “I suspect X is causing the issue, so I will do Y to test/fix that.”  
- **Repeated quick fixes without resolution:** If a particular issue keeps occurring (even after quick patches), don’t just apply the same band-aid again. Investigate deeper. For instance, restarting a service to solve a memory leak is fine once, but doing it daily without fixing the leak is an antipattern. It creates complacency and technical debt.  
- **Silent failures:** Never catch an exception just to ignore it (“swallowing” exceptions) or return an error code without logging. This makes bugs hide. Instead, at least log the error with details. In production, silent failures can cascade into much larger issues. An example antipattern: a task fails internally but the system proceeds without output – now you have wrong data with no clue why. Always surface errors somewhere.  
- **Panic and blame:** In a crunch, pointing fingers or panicking wastes time. *“The Operating System is Fine.”* – that is, assume external systems (OS, standard libraries) are probably correct. It’s usually your code or misunderstanding. Don’t default to “it must be a bug in the framework/OS” unless you have strong evidence. Even if it is, you need a workaround. And never attack colleagues; focus on solving the problem as a team.  
- **Debugging in production without safeguards:** Printing debug info or running a debugger on a production system can be risky. Avoid practices like enabling verbose debug logs in prod without bounds (filling up disk), or pausing a live process with a debugger (freezing service for users). If you must debug in prod, use tools designed for it (live tracing, or copy prod data to a staging environment to reproduce there).  
- **Not keeping context:** When debugging, avoid making changes while forgetting to restore context. Example: changing a config temporarily and not changing it back. Or testing a fix on your local machine with different environment variables and assuming it’s fixed everywhere. Always track what context a test or fix was done under. Otherwise, you might think a bug is fixed when it was only hidden by a different environment.  
- **Ignoring small anomalies:** Small warnings or non-critical errors might be early signs of a bigger issue. Don’t dismiss them. For instance, if logs show a non-fatal error happening frequently that “doesn’t impact users (yet)”, investigate it – it may uncover a logic error that could escalate.  
- **Poor logging practices:** Logging too little (e.g., just “Error occurred” without detail) or too much (dumping huge data indiscriminately) are both antipatterns. The former leaves you blind, the latter makes finding the useful info hard and can impact performance. Avoid gigantic single-line logs or logs without context. Log key events with relevant details (identifiers, state) at appropriate levels.  
- **No monitoring/alerting:** Not having monitors to catch anomalies (like error rate spikes, increased latency, high memory usage) is an antipattern in production environments. It leads to finding out problems only when users report them. Always have some form of automated eyes on your system, and avoid the pattern of relying purely on manual checks or luck to discover issues.

#### Heuristics & Checklists
- **Log and trace first:** When an issue is reported, check logs and metrics at the time of the issue. 90% of the time, the logs will contain the clue (an exception stack trace, or a spike in a certain metric) that jumpstarts the investigation. Ensure you know where to find logs and that they have timestamps and severity levels.  
- **Recent changes:** Always ask “What changed recently?” A high percentage of bugs, especially production incidents, come from recent deployments or config changes. Use version control history, deployment logs, or a diff of config files to see what’s new. If the bug wasn’t there before a certain release, the diff of that release is prime suspect area.  
- **Binary search for failure cause:** If you have a multi-step process or a long function, use *binary chop* debugging. For instance, if data gets corrupted through a pipeline, check midway through: is it good or bad at that point? Keep halving the interval. Similarly, in source control, use `git bisect` to find which commit introduced the bug by testing halfway points. This methodical narrowing quickly pinpoints offending code.  
- **Minimal test case:** Try to extract a minimal test case that demonstrates the bug (particularly for algorithmic or data-related bugs). This might mean creating a small script or unit test that triggers the same failure. A minimal case removes noise and makes debugging focused. If it’s not initially clear, iteratively simplify the input or state until you can’t simplify further without the bug disappearing.  
- **Check invariants while debugging:** When stepping through code or analyzing logs, verify if the key invariants are holding at various points. If something that “should never happen” has happened by a certain line, you’ve discovered the where/when of the breach. Many debuggers allow adding watch expressions or conditional breakpoints – use them to pause when a variable goes out-of-range, etc.  
- **Dump state on error:** If an error is hard to reproduce locally, modify the code in production (or a staging environment) to dump extensive state when the error occurs. For example, on an unexpected exception, log the entire object or context. This one-time dump can give clues (like a configuration value or internal state) that weren’t originally logged. Just be mindful of sensitive info – mask or avoid personal data in dumps.  
- **Don’t forget environment factors:** Is the bug possibly caused by environment differences? (Different OS, Python version, 32-bit vs 64-bit, locale, timezone, etc.) Have a checklist of environment factors to compare between a working scenario and a failing scenario. Sometimes the “bug in code” is actually a difference in environment or configuration.  
- **Memory and resource leaks:** If the issue is performance degradation over time, consider leak possibilities. Use monitoring or profiling tools to see if memory, file handles, or other resources are growing without bound. If so, track allocations or use debugging tools (like Python’s `tracemalloc` or C++ valgrind) to find where leaks occur.  
- **Ask for a second set of eyes:** If you’re stuck, pair up with a colleague. Explain the problem and what you’ve found. Teaching it to someone often reveals something you overlooked. They might ask a question that leads to insight. Debugging by rubber-ducking (explaining step by step) or pair debugging can be much more effective than solo after a certain point.  
- **Restore and test after fix:** Once you think you have a fix, test it in an environment as close to prod as possible. If it’s a data issue, use a copy of production data to verify the fix. Also, remove any extra logging or debug changes you added, and rollback any temporary measures (like manual hotfixes) to ensure the system is truly fixed and in a clean state.  
- **Update tests and monitors:** After resolving, add a regression test so that particular bug doesn’t sneak back in. Also consider if you can add a monitor or alert for the future that would catch a similar issue sooner (e.g., if it was a silent data corruption, maybe add a periodic data consistency check).

#### Key Quotes / Mnemonics
- “Don’t Panic.”  
- “Read the Damn Error Message.”  
- “The Operating System is Fine.”  
- “Reproduce It!”  
- “Fix the problem, not the blame.”

#### “When in doubt” Defaults
- **When in doubt, suspect your own code:** If you’re unsure where a bug lies, default assumption should be “it’s probably on our side.” This will drive you to gather evidence and either confirm or eliminate your code as the cause. It prevents wild goose chases blaming externals that are usually stable.  
- **When in doubt, add logging:** If a part of the system is mysterious or non-transparent, add logging around it by default. Having more information is generally better than less when hunting a bug. You can always remove or reduce logs later.  
- **When in doubt, simplify the scenario:** Strip the problem down. Test under a simpler configuration, use a smaller dataset, or isolate the component. By removing variables, you reduce confusion. If the bug goes away when you simplify, add pieces back until it reappears – that last piece is the culprit.  
- **When in doubt, roll back or feature-flag off:** If a production issue is critical and you’re not sure of the fix yet, the safest default action is to mitigate impact – e.g., roll back to a previous stable version, or turn off the feature via a flag. This buys time to properly diagnose without pressure. Always choose the known-good state over a risky quick change when users are on the line.  
- **When in doubt, take a break:** Debugging can be mentally exhausting. If you find yourself spinning in circles, a short break or a good night’s sleep can reset your mind. Often, the solution becomes clear when you return with fresh eyes. As a default, if you’ve spent many hours with no progress, step away briefly – it often saves time in the long run.
